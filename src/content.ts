// Content Script
console.log("Kairu AI Content Script loaded");

// Kairu settings
const KAIRU_CONTAINER_ID = "kairu-ai-container";
const KAIRU_INPUT_ID = "kairu-ai-input";

// Kairu enabled state
let kairuEnabled = false;

// Flag to allow AI operations temporarily
let isAIOperating = false;

// Conversation history (keep last 30 messages)
interface Message {
  role: "user" | "assistant";
  content: string;
}
let conversationHistory: Message[] = [];
const MAX_HISTORY_LENGTH = 30;

// Storage keys
const STORAGE_KEYS = {
  LOGS: "kairu_logs",
  CHAT_HISTORY: "kairu_chat_history",
  ENABLED: "kairu_enabled",
  CONVERSATION: "kairu_conversation",
};

// Check if extension context is valid
function isExtensionContextValid(): boolean {
  try {
    // Try to access chrome.runtime.id
    return !!chrome.runtime?.id;
  } catch (e) {
    return false;
  }
}

// Handle extension context invalidation error
function handleContextInvalidation(error: any): boolean {
  const errorMessage = error?.message || String(error);
  if (errorMessage.includes("Extension context invalidated")) {
    console.warn("Extension context invalidated. Please reload the page.");
    return true;
  }
  return false;
}

// Save logs to storage
async function saveLogs() {
  if (!isExtensionContextValid()) return;

  const logContent = document.getElementById("kairu-log-content");
  if (!logContent) return;

  try {
    const logHtml = logContent.innerHTML;
    await chrome.storage.local.set({ [STORAGE_KEYS.LOGS]: logHtml });
    console.log("[Kairu] Logs saved to storage");
  } catch (error) {
    if (handleContextInvalidation(error)) return;
    console.error("[Kairu] Failed to save logs:", error);
  }
}

// Restore logs from storage
async function restoreLogs() {
  if (!isExtensionContextValid()) return;

  const logContent = document.getElementById("kairu-log-content");
  if (!logContent) return;

  try {
    const result = await chrome.storage.local.get(STORAGE_KEYS.LOGS);
    console.log("[Kairu] Restoring logs from storage:", result);
    if (result[STORAGE_KEYS.LOGS]) {
      logContent.innerHTML = result[STORAGE_KEYS.LOGS];
      logContent.scrollTop = logContent.scrollHeight;
      console.log("[Kairu] Logs restored successfully");
    } else {
      console.log("[Kairu] No logs found in storage");
    }
  } catch (error) {
    if (handleContextInvalidation(error)) return;
    console.error("[Kairu] Failed to restore logs:", error);
  }
}

// Save chat history to storage
async function saveChatHistory() {
  if (!isExtensionContextValid()) return;

  const chatHistory = document.getElementById("kairu-chat-history");
  if (!chatHistory) return;

  try {
    const chatHtml = chatHistory.innerHTML;
    await chrome.storage.local.set({ [STORAGE_KEYS.CHAT_HISTORY]: chatHtml });
    console.log("[Kairu] Chat history saved to storage");
  } catch (error) {
    if (handleContextInvalidation(error)) return;
    console.error("[Kairu] Failed to save chat history:", error);
  }
}

// Restore chat history from storage
async function restoreChatHistory() {
  if (!isExtensionContextValid()) return;

  const chatHistory = document.getElementById("kairu-chat-history");
  if (!chatHistory) return;

  try {
    const result = await chrome.storage.local.get(STORAGE_KEYS.CHAT_HISTORY);
    console.log("[Kairu] Restoring chat history from storage:", result);
    if (result[STORAGE_KEYS.CHAT_HISTORY]) {
      chatHistory.innerHTML = result[STORAGE_KEYS.CHAT_HISTORY];
      chatHistory.scrollTop = chatHistory.scrollHeight;
      console.log("[Kairu] Chat history restored successfully");
    } else {
      console.log("[Kairu] No chat history found in storage");
    }
  } catch (error) {
    if (handleContextInvalidation(error)) return;
    console.error("[Kairu] Failed to restore chat history:", error);
  }
}

// Save enabled state to storage
async function saveEnabledState(enabled: boolean) {
  if (!isExtensionContextValid()) return;

  try {
    await chrome.storage.local.set({ [STORAGE_KEYS.ENABLED]: enabled });
    console.log("[Kairu] Enabled state saved to storage:", enabled);
  } catch (error) {
    if (handleContextInvalidation(error)) return;
    console.error("[Kairu] Failed to save enabled state:", error);
  }
}

// Restore enabled state from storage
async function restoreEnabledState() {
  if (!isExtensionContextValid()) return;

  try {
    const result = await chrome.storage.local.get(STORAGE_KEYS.ENABLED);
    console.log("[Kairu] Restoring enabled state from storage:", result);
    if (result[STORAGE_KEYS.ENABLED] !== undefined) {
      kairuEnabled = result[STORAGE_KEYS.ENABLED];
      const container = document.getElementById(KAIRU_CONTAINER_ID);
      if (container) {
        container.style.display = kairuEnabled ? "block" : "none";
      }
      console.log("[Kairu] Enabled state restored successfully:", kairuEnabled);
    } else {
      console.log("[Kairu] No enabled state found in storage");
    }
  } catch (error) {
    if (handleContextInvalidation(error)) return;
    console.error("[Kairu] Failed to restore enabled state:", error);
  }
}

// Save conversation history to storage
async function saveConversation() {
  if (!isExtensionContextValid()) return;

  try {
    await chrome.storage.local.set({
      [STORAGE_KEYS.CONVERSATION]: conversationHistory,
    });
    console.log("[Kairu] Conversation history saved to storage");
  } catch (error) {
    if (handleContextInvalidation(error)) return;
    console.error("[Kairu] Failed to save conversation:", error);
  }
}

// Restore conversation history from storage
async function restoreConversation() {
  if (!isExtensionContextValid()) return;

  try {
    const result = await chrome.storage.local.get(STORAGE_KEYS.CONVERSATION);
    console.log("[Kairu] Restoring conversation from storage:", result);
    if (result[STORAGE_KEYS.CONVERSATION]) {
      conversationHistory = result[STORAGE_KEYS.CONVERSATION];
      console.log(
        "[Kairu] Conversation restored successfully:",
        conversationHistory.length,
        "messages"
      );
    } else {
      console.log("[Kairu] No conversation found in storage");
    }
  } catch (error) {
    if (handleContextInvalidation(error)) return;
    console.error("[Kairu] Failed to restore conversation:", error);
  }
}

// Clear conversation history
function clearConversation() {
  conversationHistory = [];
  if (isExtensionContextValid()) {
    try {
      chrome.storage.local.remove(STORAGE_KEYS.CONVERSATION);
      console.log("[Kairu] Conversation cleared from storage");
    } catch (error) {
      if (handleContextInvalidation(error)) return;
      console.error("[Kairu] Failed to clear conversation:", error);
    }
  }
}

// Logger
function addLog(
  message: string,
  type: "info" | "success" | "error" | "warning" = "info"
) {
  const logContent = document.getElementById("kairu-log-content");
  if (!logContent) return;

  const time = new Date().toLocaleTimeString();
  const entry = document.createElement("div");
  entry.className = `log-entry ${type}`;
  entry.innerHTML = `<span class="log-time">[${time}]</span> ${message}`;
  logContent.appendChild(entry);
  logContent.scrollTop = logContent.scrollHeight;

  // Save to storage
  saveLogs();
}

function addRawLog(title: string, content: string) {
  const logContent = document.getElementById("kairu-log-content");
  if (!logContent) return;

  const entry = document.createElement("div");
  entry.className = "log-entry info";

  const titleElement = document.createElement("strong");
  titleElement.textContent = title;

  const contentElement = document.createElement("div");
  contentElement.className = "log-raw";
  contentElement.textContent = content; // Use textContent to preserve HTML as plain text

  entry.appendChild(titleElement);
  entry.appendChild(contentElement);

  logContent.appendChild(entry);
  logContent.scrollTop = logContent.scrollHeight;

  // Save to storage
  saveLogs();
}

function clearLog() {
  const logContent = document.getElementById("kairu-log-content");
  if (logContent) {
    logContent.innerHTML = "";
    // Clear storage as well
    if (isExtensionContextValid()) {
      try {
        chrome.storage.local.remove(STORAGE_KEYS.LOGS);
        console.log("[Kairu] Logs cleared from storage");
      } catch (error) {
        if (handleContextInvalidation(error)) return;
        console.error("[Kairu] Failed to clear logs from storage:", error);
      }
    }
  }
}

// Chat history
function addChatMessage(
  message: string,
  role: "user" | "assistant" | "system"
) {
  const chatHistory = document.getElementById("kairu-chat-history");
  if (!chatHistory) return;

  const messageDiv = document.createElement("div");
  messageDiv.className = `chat-message ${role}`;
  messageDiv.textContent = message;
  chatHistory.appendChild(messageDiv);
  chatHistory.scrollTop = chatHistory.scrollHeight;

  // Save to storage (only save user and assistant messages, not system)
  if (role !== "system") {
    saveChatHistory();
  }
}

// Add system message (status update) - returns the element so it can be updated
// Show status in the input panel
function showStatus(message: string) {
  const statusElement = document.getElementById("kairu-status");
  if (!statusElement) return;

  statusElement.textContent = message;
}

// Hide status in the input panel
function hideStatus() {
  const statusElement = document.getElementById("kairu-status");
  if (!statusElement) return;

  statusElement.textContent = "";
}

// Create Kairu UI
async function createKairuUI() {
  // Check if already exists
  if (document.getElementById(KAIRU_CONTAINER_ID)) {
    return;
  }

  // Create container
  const container = document.createElement("div");
  container.id = KAIRU_CONTAINER_ID;
  container.innerHTML = `
    <div id="kairu-character">
      <div class="kairu-avatar">
        <div class="kairu-avatar-inner">
          üê¨
        </div>
      </div>
    </div>
    <div id="kairu-input-panel" style="display: none;">
      <div class="kairu-panel-header">
        <span>Kairu„Åè„Çì</span>
        <button id="kairu-reset-btn" title="‰ºöË©±„Çí„É™„Çª„ÉÉ„Éà">üîÑ</button>
      </div>
      <div id="kairu-chat-history"></div>
      <div class="kairu-input-container">
        <textarea id="${KAIRU_INPUT_ID}" placeholder="„ÇÑ„Çä„Åü„ÅÑ„Åì„Å®„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ..."></textarea>
        <button id="kairu-submit-btn">ÈÄÅ‰ø°</button>
      </div>
      <details id="kairu-debug-log">
        <summary>ÂÆüË°å„É≠„Ç∞</summary>
        <div id="kairu-log-content"></div>
      </details>
      <div id="kairu-status"></div>
    </div>
  `;

  // Add styles
  const style = document.createElement("style");
  style.textContent = `
    #${KAIRU_CONTAINER_ID} {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 2147483647;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: none;
    }

    #kairu-character {
      position: relative;
      right: 8px;
      bottom: 8px;
      z-index: 1;
      cursor: pointer;
      transition: transform 0.2s;
    }

    #kairu-character:hover {
      transform: scale(1.1);
    }

    #kairu-character.loading {
      animation: pendulum 1s ease-in-out infinite;
    }

    @keyframes pendulum {
      0%, 100% {
        transform: rotate(-15deg);
      }
      50% {
        transform: rotate(15deg);
      }
    }

    .kairu-avatar {
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      padding: 2px;
    }

    .kairu-avatar-inner {
      width: 100%;
      height: 100%;
      background: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #kairu-input-panel {
      position: absolute;
      bottom: 0px;
      right: 0;
      width: 320px;
      background: rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      padding: 16px 16px 0px;
      animation: slideUp 0.3s ease;
    }

    #kairu-status {
      display: flex;
      align-items: center;
      height: 86px;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .kairu-panel-header {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #333;
      border-bottom: 2px solid #eee;
      padding-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #kairu-reset-btn {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    #kairu-reset-btn:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    #kairu-reset-btn:active {
      background: rgba(0, 0, 0, 0.1);
    }

    #kairu-chat-history {
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .chat-message {
      padding: 8px 12px;
      border-radius: 12px;
      max-width: 90%;
      font-size: 13px;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .chat-message.user {
      align-self: flex-end;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .chat-message.assistant {
      align-self: flex-start;
      background: rgba(245, 245, 245, 0.8);
      color: #333;
    }

    .chat-message.system {
      align-self: center;
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
      font-size: 12px;
      font-style: italic;
      border: 1px solid rgba(102, 126, 234, 0.2);
    }

    .kairu-input-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #${KAIRU_INPUT_ID} {
      width: 100%;
      min-height: 60px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 14px;
      resize: vertical;
      box-sizing: border-box;
      font-family: inherit;
      background: rgba(255, 255, 255, 0.5);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #${KAIRU_INPUT_ID}:focus {
      outline: none;
      border-color: #667eea;
      background: rgba(255, 255, 255, 0.7);
    }

    #kairu-submit-btn {
      width: 100%;
      padding: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    #kairu-submit-btn:hover {
      opacity: 0.9;
    }

    #kairu-submit-btn:active {
      opacity: 0.8;
    }

    #kairu-debug-log {
      margin-top: 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px;
      background: #fafafa;
    }

    #kairu-debug-log summary {
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      color: #666;
      padding: 4px;
      user-select: none;
    }

    #kairu-debug-log summary:hover {
      color: #333;
    }

    #kairu-log-content {
      margin-top: 8px;
      max-height: 200px;
      overflow-y: auto;
      font-size: 11px;
      font-family: monospace;
      line-height: 1.4;
    }

    .log-entry {
      padding: 4px 8px;
      margin: 2px 0;
      border-radius: 4px;
      background: white;
      border-left: 3px solid #ccc;
    }

    .log-entry.info {
      border-left-color: #2196F3;
    }

    .log-entry.success {
      border-left-color: #4CAF50;
    }

    .log-entry.error {
      border-left-color: #f44336;
    }

    .log-entry.warning {
      border-left-color: #FF9800;
    }

    .log-time {
      color: #999;
      font-size: 10px;
    }

    .log-raw {
      margin-top: 8px;
      padding: 8px;
      background: #f0f0f0;
      border-radius: 4px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 150px;
      overflow-y: auto;
    }
  `;

  document.head.appendChild(style);
  document.body.appendChild(container);

  // Restore logs, chat history, conversation, and enabled state from storage
  await restoreLogs();
  await restoreChatHistory();
  await restoreConversation();
  await restoreEnabledState();

  // Add event listeners
  const character = document.getElementById("kairu-character")!;
  const inputPanel = document.getElementById("kairu-input-panel")!;
  const input = document.getElementById(KAIRU_INPUT_ID) as HTMLTextAreaElement;
  const submitBtn = document.getElementById(
    "kairu-submit-btn"
  ) as HTMLButtonElement;
  const resetBtn = document.getElementById(
    "kairu-reset-btn"
  ) as HTMLButtonElement;

  // Reset button click
  resetBtn.addEventListener("click", () => {
    if (confirm("‰ºöË©±Â±•Ê≠¥„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü")) {
      // Clear conversation history
      clearConversation();

      // Clear chat UI
      const chatHistory = document.getElementById("kairu-chat-history");
      if (chatHistory) {
        chatHistory.innerHTML = "";
        saveChatHistory(); // Save empty state
      }

      addLog("‰ºöË©±Â±•Ê≠¥„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü", "info");
    }
  });

  // Show input panel on hover
  character.addEventListener("mouseenter", () => {
    inputPanel.style.display = "block";
    // Scroll chat history to bottom when panel is shown
    const chatHistory = document.getElementById("kairu-chat-history");
    if (chatHistory) {
      chatHistory.scrollTop = chatHistory.scrollHeight;
    }
  });

  // Keep panel open when hovering over it
  container.addEventListener("mouseleave", () => {
    inputPanel.style.display = "none";
  });

  // Submit button click
  submitBtn.addEventListener("click", async () => {
    const userInput = input.value.trim();
    if (!userInput) return;

    submitBtn.disabled = true;
    submitBtn.textContent = "ÈÄÅ‰ø°‰∏≠...";
    clearLog();
    addLog(`„É¶„Éº„Ç∂„ÉºÂÖ•Âäõ: ${userInput}`, "info");

    // Start loading animation
    character.classList.add("loading");

    // Add user message to chat history
    addChatMessage(userInput, "user");

    try {
      // Check if extension context is valid
      if (!isExtensionContextValid()) {
        addLog(
          "Êã°ÂºµÊ©üËÉΩ„ÅåÊõ¥Êñ∞„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
          "error"
        );
        addChatMessage(
          "„Ç®„É©„Éº: Êã°ÂºµÊ©üËÉΩ„ÅåÊõ¥Êñ∞„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ (F5) „Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
          "assistant"
        );
        return;
      }

      // Get API key
      const response = await chrome.runtime.sendMessage({
        type: "GET_API_KEY",
      });
      const apiKey = response.apiKey;

      if (!apiKey) {
        addLog("API„Ç≠„Éº„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì", "error");
        addChatMessage(
          "„Ç®„É©„Éº: API„Ç≠„Éº„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÊã°ÂºµÊ©üËÉΩ„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Åã„ÇâË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
          "assistant"
        );
        return;
      }

      // Add user message to conversation history
      conversationHistory.push({
        role: "user",
        content: userInput,
      });

      // Keep only last 30 messages
      if (conversationHistory.length > MAX_HISTORY_LENGTH) {
        conversationHistory = conversationHistory.slice(-MAX_HISTORY_LENGTH);
      }

      // Call OpenAI API
      addLog("OpenAI API„ÇíÂëº„Å≥Âá∫„Åó„Å¶„ÅÑ„Åæ„Åô...", "info");
      const aiResponse = await callOpenAI(apiKey, userInput);
      addRawLog("AIÂøúÁ≠î (Áîü„Éá„Éº„Çø)", aiResponse);

      // Add assistant response to conversation history
      conversationHistory.push({
        role: "assistant",
        content: aiResponse,
      });

      // Keep only last 30 messages
      if (conversationHistory.length > MAX_HISTORY_LENGTH) {
        conversationHistory = conversationHistory.slice(-MAX_HISTORY_LENGTH);
      }

      // Save conversation to storage
      saveConversation();

      // Parse response and execute actions
      await processAIResponse(aiResponse);
      input.value = "";
    } catch (error) {
      console.error("Error:", error);

      // Handle context invalidation error
      if (handleContextInvalidation(error)) {
        addLog(
          "Êã°ÂºµÊ©üËÉΩ„ÅåÊõ¥Êñ∞„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
          "error"
        );
        addChatMessage(
          "„Ç®„É©„Éº: Êã°ÂºµÊ©üËÉΩ„ÅåÊõ¥Êñ∞„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ (F5) „Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
          "assistant"
        );
        return;
      }

      const errorMsg = `„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${(error as Error).message}`;
      addLog(errorMsg, "error");
      addChatMessage(errorMsg, "assistant");
    } finally {
      // Stop loading animation
      character.classList.remove("loading");
      submitBtn.disabled = false;
      submitBtn.textContent = "ÈÄÅ‰ø°";
    }
  });

  // Allow Cmd+Enter (or Ctrl+Enter on Windows) to submit
  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      submitBtn.click();
    }
  });
}

// Get page HTML structure
function getPageHTML(): string {
  // Get body HTML, excluding Kairu UI
  const bodyClone = document.body.cloneNode(true) as HTMLElement;

  // Remove Kairu UI
  const kairuContainer = bodyClone.querySelector(`#${KAIRU_CONTAINER_ID}`);
  if (kairuContainer) {
    kairuContainer.remove();
  }

  // Remove script tags, style tags, and comments
  bodyClone
    .querySelectorAll("script, style, noscript, svg, path")
    .forEach((el) => el.remove());

  // Get HTML
  let html = bodyClone.innerHTML;

  // Clean up excessive whitespace
  html = html.replace(/\s+/g, " ").replace(/>\s+</g, "><").trim();

  return html;
}

// Get interactive elements on the page (simplified list for reference)
function getPageElements(): string {
  const inputs = Array.from(
    document.querySelectorAll("input, textarea, select")
  );
  const buttons = Array.from(
    document.querySelectorAll("button, [role='button'], a")
  );

  // Helper function to check if element is visible
  const isVisible = (el: Element): boolean => {
    const style = window.getComputedStyle(el);
    return (
      style.display !== "none" &&
      style.visibility !== "hidden" &&
      style.opacity !== "0" &&
      (el as HTMLElement).offsetWidth > 0 &&
      (el as HTMLElement).offsetHeight > 0
    );
  };

  const inputInfo = inputs
    .filter((el) => !el.closest(`#${KAIRU_CONTAINER_ID}`) && isVisible(el))
    .map((el, i) => {
      const tag = el.tagName.toLowerCase();
      const type = el.getAttribute("type") || "text";
      const name = el.getAttribute("name") || "";
      const id = el.getAttribute("id") || "";
      const placeholder = el.getAttribute("placeholder") || "";
      const value = (el as HTMLInputElement).value?.substring(0, 50) || ""; // Increased from 20 to 50
      return `${i + 1}. <${tag}${type !== "text" ? ` type="${type}"` : ""}${
        name ? ` name="${name}"` : ""
      }${id ? ` id="${id}"` : ""}${
        placeholder ? ` placeholder="${placeholder}"` : ""
      }${value ? ` value="${value}"` : ""}>`;
    })
    .join("\n");

  const buttonInfo = buttons
    .filter((el) => !el.closest(`#${KAIRU_CONTAINER_ID}`) && isVisible(el))
    .map((el, i) => {
      const tag = el.tagName.toLowerCase();
      const text = el.textContent?.trim().substring(0, 80) || ""; // Increased from 30 to 80
      const id = el.getAttribute("id") || "";
      const className = el.getAttribute("class")?.split(" ")[0] || "";
      const role = el.getAttribute("role") || "";
      const href = el.getAttribute("href") || "";
      return `${i + 1}. <${tag}${id ? ` id="${id}"` : ""}${
        className ? ` class="${className}"` : ""
      }${role ? ` role="${role}"` : ""}${
        href ? ` href="${href.substring(0, 50)}"` : ""
      }> "${text}"`;
    })
    .join("\n");

  return `
ÂÖ•ÂäõÂèØËÉΩ„Å™Ë¶ÅÁ¥†:
${inputInfo || "„Å™„Åó"}

„ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ„Å™Ë¶ÅÁ¥†:
${buttonInfo || "„Å™„Åó"}
`;
}

// Call OpenAI API with page information
async function callOpenAI(
  apiKey: string,
  userMessage: string
): Promise<string> {
  showStatus("üì¶ „Éö„Éº„Ç∏ÊÉÖÂ†±„ÇíÂèéÈõÜ‰∏≠...");

  // Collect page information
  addLog("„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñË¶ÅÁ¥†„ÇíÂèñÂæó‰∏≠...", "info");
  const pageElements = getPageElements();
  addRawLog("Ê§úÂá∫„Åï„Çå„Åü„Éö„Éº„Ç∏Ë¶ÅÁ¥†", pageElements);

  addLog("„Éö„Éº„Ç∏HTMLÊßãÈÄ†„ÇíÂèñÂæó‰∏≠...", "info");
  const pageHTML = getPageHTML();
  addRawLog("ÈÄÅ‰ø°„Åô„ÇãHTMLÊßãÈÄ†", pageHTML);

  const pageContext = `
ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏ÊÉÖÂ†±:
- URL: ${window.location.href}
- „Çø„Ç§„Éà„É´: ${document.title}

## „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñË¶ÅÁ¥†ÔºàÈáçË¶ÅÔºâ
‰ª•‰∏ã„ÅØ„ÄÅ„ÇØ„É™„ÉÉ„ÇØ„ÇÑÂÖ•Âäõ„ÅåÂèØËÉΩ„Å™‰∏ªË¶Å„Å™Ë¶ÅÁ¥†„ÅÆ„É™„Çπ„Éà„Åß„Åô„ÄÇ

${pageElements}

## „Éö„Éº„Ç∏„ÅÆHTMLÊßãÈÄ†
„Éö„Éº„Ç∏ÂÖ®‰Ωì„ÅÆHTMLÊßãÈÄ†„Åß„Åô„ÄÇÊ≠£Á¢∫„Å™„Çª„É¨„ÇØ„Çø„Çí‰ΩúÊàê„Åô„Çã„Åü„ÇÅ„Å´‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

${pageHTML}
`;

  showStatus("üê¨üí≠ Kairu„Åè„Çì„ÅåÂá¶ÁêÜ„ÇíËÄÉ„Åà„Å¶„ÅÑ„Åæ„Åô...");

  const systemPrompt = `„ÅÇ„Å™„Åü„ÅØKairu„Å®„ÅÑ„ÅÜ„Éñ„É©„Ç¶„Ç∂Êìç‰Ωú„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ„É¶„Éº„Ç∂„Éº„ÅÆÊåáÁ§∫„Å´Âæì„Å£„Å¶„Éñ„É©„Ç¶„Ç∂„ÇíÊìç‰Ωú„Åó„Åæ„Åô„ÄÇ

## ÈáçË¶Å„Å™ÊåáÁ§∫

1. **„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñË¶ÅÁ¥†„É™„Çπ„Éà„ÇíÂÑ™ÂÖàÁöÑ„Å´ÂèÇÁÖß„Åô„Çã**
   - „Åæ„Åö„Äå„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñË¶ÅÁ¥†„Äç„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ
   - „Åì„ÅÆ„É™„Çπ„Éà„Å´„ÅØ„ÄÅ„ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ„Å™„Éú„Çø„É≥„ÇÑÂÖ•ÂäõÊ¨Ñ„ÅåÁï™Âè∑‰ªò„Åç„ÅßÊï¥ÁêÜ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô
   - Êìç‰ΩúÂØæË±°„ÅÆË¶ÅÁ¥†„ÇíÁâπÂÆö„Åô„ÇãÈöõ„ÅØ„ÄÅ„Åì„ÅÆ„É™„Çπ„Éà„ÇíÊúÄÂÑ™ÂÖà„Åß‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ
   - „É™„Çπ„Éà„Å´Ë®òËºâ„Åï„Çå„Å¶„ÅÑ„ÇãË¶ÅÁ¥†„ÅÆÂ±ûÊÄßÔºàid, name, typeÁ≠âÔºâ„Çí‰Ωø„Å£„Å¶„Çª„É¨„ÇØ„Çø„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ

2. **Ê≠£Á¢∫„Å™„Çª„É¨„ÇØ„Çø„ÅÆ‰ΩúÊàê - Áµ∂ÂØæ„Å´ÂÆà„Çã„Åπ„Åç„É´„Éº„É´**
   - **Á¶ÅÊ≠¢**: \`[href*="Â∫óÂêç"]\` „ÇÑ \`[href*="„Éú„Çø„É≥„ÅÆ„ÉÜ„Ç≠„Çπ„Éà"]\` „ÅÆ„Çà„ÅÜ„Å™„Çª„É¨„ÇØ„Çø„ÅØÁµ∂ÂØæ„Å´‰ΩøÁî®Á¶ÅÊ≠¢
   - **ÁêÜÁî±**: hrefÂ±ûÊÄß„Å´„ÅØURLÔºà‰æã: "/tokyo/rstdtl/..."Ôºâ„ÅåÂÖ•„Å£„Å¶„Åä„Çä„ÄÅ„ÉÜ„Ç≠„Çπ„ÉàÂÜÖÂÆπ„ÅØÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì
   - **Ê≠£„Åó„ÅÑÊñπÊ≥ï**: „É™„É≥„ÇØ„ÇÑ„Éú„Çø„É≥„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàÂÜÖÂÆπ„Åß„ÇØ„É™„ÉÉ„ÇØ„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅÂøÖ„Åö\`text\`„Éë„É©„É°„Éº„Çø„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ

   **„Çª„É¨„ÇØ„Çø„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç:**
   1. idÂ±ûÊÄß„Åå„ÅÇ„ÇãÂ†¥Âêà: \`#element-id\`
   2. nameÂ±ûÊÄß„Åå„ÅÇ„ÇãÂ†¥Âêà: \`[name="element-name"]\`
   3. classÂ±ûÊÄß„ÅÆ„Åø„ÅÆÂ†¥Âêà: \`.class-name\`
   4. „ÉÜ„Ç≠„Çπ„ÉàÂÜÖÂÆπ„Åß„ÇØ„É™„ÉÉ„ÇØ„Åô„ÇãÂ†¥Âêà: \`text\`„Éë„É©„É°„Éº„Çø„Çí‰ΩøÁî®Ôºàselector„ÅØ‰∏çË¶ÅÔºâ

   **ÂÖ∑‰Ωì‰æã:**
   - ‚ùå ÈñìÈÅï„ÅÑ: \`{"action": "click", "selector": "a[href*='ÂíåÁâõ„Çâ„Éº„ÇÅ„Çì']"}\`
   - ‚úÖ Ê≠£Ëß£: \`{"action": "click", "text": "ÂíåÁâõ„Çâ„Éº„ÇÅ„Çì Ê•µ"}\`
   - ‚úÖ Ê≠£Ëß£: \`{"action": "click", "selector": "a.list-rst__rst-name-target"}\`
   - ‚úÖ Ê≠£Ëß£: \`{"action": "click", "selector": "button#submit-btn"}\`

3. **„ÉÜ„Ç≠„Çπ„Éà„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆÂèÇÁÖß**
   - „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñË¶ÅÁ¥†„É™„Çπ„Éà„ÅßË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÄÅ„Éö„Éº„Ç∏„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ
   - „ÉÜ„Ç≠„Çπ„Éà„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅØ„Éö„Éº„Ç∏„Å´Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÊñáÂ≠óÂàó„ÅÆ„Åø„Åß„Åô

4. **Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà**
   - „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñË¶ÅÁ¥†„É™„Çπ„Éà„Å®„ÉÜ„Ç≠„Çπ„Éà„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆ‰∏°Êñπ„ÇíË¶ã„Å¶„ÇÇË©≤ÂΩì„Åô„ÇãË¶ÅÁ¥†„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅmessage„Åß„Äå„Äú„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„Äç„Å®‰ºù„Åà„Çã
   - actions„ÅØÁ©∫ÈÖçÂàó„Å´„Åô„Çã

Êìç‰ΩúÂèØËÉΩ„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥:
1. click: Ë¶ÅÁ¥†„Çí„ÇØ„É™„ÉÉ„ÇØ
   - selector„ÅßÊåáÂÆö: \`{"action": "click", "selector": "button.submit-btn"}\`
   - text„ÅßÊåáÂÆö: \`{"action": "click", "text": "„É≠„Ç∞„Ç§„É≥"}\`
   - Êé®Â•®: „ÉÜ„Ç≠„Çπ„Éà„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãË¶ÅÁ¥†„ÅØ„ÄÅtext„Éë„É©„É°„Éº„Çø„Çí‰ΩøÁî®„Åô„ÇãÊñπ„ÅåÁ¢∫ÂÆü„Åß„Åô
2. type: „Éï„Ç©„Éº„É†„Å´ÂÖ•Âäõ (selector„ÅßË¶ÅÁ¥†„ÇíÊåáÂÆö„ÄÅvalue„ÅßÂÖ•ÂäõÂÄ§„ÇíÊåáÂÆö)
3. navigate: „Éö„Éº„Ç∏ÈÅ∑Áßª (url„ÅßÊåáÂÆö)
4. scroll: „Çπ„ÇØ„É≠„Éº„É´ (direction„Åß"up"„Åã"down"„ÇíÊåáÂÆö)
5. get_info: „Éö„Éº„Ç∏ÊÉÖÂ†±„ÇíÂèñÂæó (type„Åß"title", "url", "text"„ÇíÊåáÂÆö)

ÂøúÁ≠îÂΩ¢Âºè (ÂøÖ„ÅöJSON):
{
  "message": "„É¶„Éº„Ç∂„Éº„Å∏„ÅÆË™¨ÊòéÔºà‰Ωï„Çí„Åô„Çã„ÅãÔºâ",
  "actions": [
    {"action": "type", "selector": "input[name='q']", "value": "Ê§úÁ¥¢„ÉØ„Éº„Éâ"},
    {"action": "click", "text": "Ê§úÁ¥¢"}
  ]
}

**ÈáçË¶Å„Å™Ê≥®ÊÑè‰∫ãÈ†Ö:**
- „É™„É≥„ÇØ„ÇÑ„Éú„Çø„É≥„Çí„ÉÜ„Ç≠„Çπ„Éà„Åß„ÇØ„É™„ÉÉ„ÇØ„Åô„ÇãÂ†¥Âêà„ÄÅ\`selector\`„Éë„É©„É°„Éº„Çø„ÅØÂÆåÂÖ®„Å´ÁúÅÁï•„Åó„ÄÅ\`text\`„Éë„É©„É°„Éº„Çø„ÅÆ„Åø„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ
- ‰æã: \`{"action": "click", "text": "ÂíåÁâõ„Çâ„Éº„ÇÅ„Çì Ê•µ"}\` ‚Üê selector„ÅØ‰∏çË¶Å
- \`[href*="..."]\`„Çª„É¨„ÇØ„Çø„ÅØÁµ∂ÂØæ„Å´‰Ωø„Çè„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ

‰ºöË©±„ÅÆ„Åø„ÅÆÂ†¥Âêà„ÅØactions„ÇíÁ©∫ÈÖçÂàó„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;

  // Build messages array with conversation history
  const messages: any[] = [
    {
      role: "system",
      content: systemPrompt,
    },
    // Add conversation history (last 30 messages)
    ...conversationHistory,
    // Add current user message with page context
    {
      role: "user",
      content: pageContext + "\n\n„É¶„Éº„Ç∂„Éº„ÅÆÊåáÁ§∫: " + userMessage,
    },
  ];

  // Calculate approximate token count (rough estimate: 1 token ‚âà 4 characters)
  const requestBody = JSON.stringify({
    model: "gpt-5-nano",
    messages: messages,
  });
  const approxTokens = Math.ceil(requestBody.length / 4);

  addLog(
    `OpenAI API„Å´„É™„ÇØ„Ç®„Çπ„ÉàÈÄÅ‰ø°‰∏≠... (Â±•Ê≠¥: ${conversationHistory.length}‰ª∂, Êé®ÂÆö„Éà„Éº„ÇØ„É≥: ${approxTokens})`,
    "info"
  );

  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: requestBody,
  });

  if (!response.ok) {
    hideStatus();
    const errorText = await response.text();
    addLog(`API„Ç®„É©„ÉºË©≥Á¥∞: ${errorText}`, "error");
    throw new Error(`API request failed: ${response.status} - ${errorText}`);
  }

  const data = await response.json();
  hideStatus();
  return data.choices[0].message.content;
}

// Process AI response and execute actions
async function processAIResponse(aiResponse: string): Promise<void> {
  try {
    // Try to parse as JSON
    const parsed = JSON.parse(aiResponse);
    addLog("AIÂøúÁ≠î„ÇíËß£Êûê„Åó„Åæ„Åó„Åü", "success");

    // Display message to user
    if (parsed.message) {
      addLog(`„É°„ÉÉ„Çª„Éº„Ç∏: ${parsed.message}`, "info");
      // Add assistant message to chat history
      addChatMessage(parsed.message, "assistant");
    }

    // Execute actions
    if (parsed.actions && Array.isArray(parsed.actions)) {
      addLog(`${parsed.actions.length}ÂÄã„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË°å„Åó„Åæ„Åô`, "info");
      for (let i = 0; i < parsed.actions.length; i++) {
        const action = parsed.actions[i];
        addLog(
          `„Ç¢„ÇØ„Ç∑„Éß„É≥ ${i + 1}/${parsed.actions.length}: ${action.action}`,
          "info"
        );
        try {
          await executeAction(action);
        } catch (error) {
          const errorMsg = `„Ç¢„ÇØ„Ç∑„Éß„É≥ÂÆüË°å„Ç®„É©„Éº: ${(error as Error).message}`;
          addLog(errorMsg, "error");
          // Also show error in chat
          addChatMessage(`‚ùå ${errorMsg}`, "assistant");
        }
        // Wait between actions (longer delay to see each action clearly)
        await new Promise((resolve) => setTimeout(resolve, 800));
      }
      addLog("„Åô„Åπ„Å¶„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü", "success");
    } else {
      addLog("ÂÆüË°å„Åô„Çã„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì", "info");
    }
  } catch (e) {
    // If not JSON, treat as plain text
    addLog("JSONËß£ÊûêÂ§±Êïó„ÄÇ„ÉÜ„Ç≠„Çπ„Éà„Å®„Åó„Å¶Ë°®Á§∫„Åó„Åæ„Åô", "warning");
    addChatMessage(aiResponse, "assistant");
  }
}

// Execute a single action
async function executeAction(action: any): Promise<void> {
  console.log("Executing action:", action);

  // Enable AI operation mode to allow interactions
  isAIOperating = true;
  addLog("AIÊìç‰Ωú„É¢„Éº„Éâ: ON", "info");

  try {
    switch (action.action) {
      case "click":
        await clickElement(action.selector, action.text);
        break;
      case "type":
        await typeInElement(action.selector, action.value);
        break;
      case "navigate":
        window.location.href = action.url;
        break;
      case "scroll":
        scrollPage(action.direction);
        break;
      case "get_info":
        const info = getPageInfo(action.type);
        console.log("Page info:", info);
        break;
      default:
        console.warn("Unknown action:", action.action);
    }
  } finally {
    // Disable AI operation mode after a short delay
    setTimeout(() => {
      isAIOperating = false;
      addLog("AIÊìç‰Ωú„É¢„Éº„Éâ: OFF", "info");
    }, 100);
  }
}

// Click an element
async function clickElement(selector?: string, text?: string): Promise<void> {
  let element: HTMLElement | null = null;

  if (selector) {
    addLog(`„Çª„É¨„ÇØ„Çø„ÅßË¶ÅÁ¥†„ÇíÊ§úÁ¥¢: ${selector}`, "info");
    element = document.querySelector(selector);
  }

  if (!element && text) {
    addLog(`„ÉÜ„Ç≠„Çπ„Éà„ÅßË¶ÅÁ¥†„ÇíÊ§úÁ¥¢: ${text}`, "info");
    // Search by text content
    const allElements = document.querySelectorAll("button, a, [role='button']");
    for (const el of Array.from(allElements)) {
      if (el.textContent?.trim().includes(text)) {
        element = el as HTMLElement;
        break;
      }
    }
  }

  if (element) {
    element.click();
    addLog(
      `Ë¶ÅÁ¥†„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åæ„Åó„Åü: ${
        element.tagName
      } - ${element.textContent?.substring(0, 30)}`,
      "success"
    );
    console.log("Clicked element:", element);
  } else {
    const errorMsg = `Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü (selector: ${selector}, text: ${text})`;
    addLog(errorMsg, "error");
    throw new Error(errorMsg);
  }
}

// Type into an input element
async function typeInElement(selector: string, value: string): Promise<void> {
  addLog(`ÂÖ•ÂäõÊ¨Ñ„ÇíÊ§úÁ¥¢: ${selector}`, "info");
  const element = document.querySelector(selector) as
    | HTMLInputElement
    | HTMLTextAreaElement;

  if (element) {
    element.value = value;
    element.dispatchEvent(new Event("input", { bubbles: true }));
    element.dispatchEvent(new Event("change", { bubbles: true }));
    addLog(
      `ÂÖ•Âäõ„Åó„Åæ„Åó„Åü: "${value}" ‚Üí ${element.tagName}[${
        element.name || element.id
      }]`,
      "success"
    );
    console.log("Typed into element:", element);
  } else {
    const errorMsg = `ÂÖ•ÂäõÊ¨Ñ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü: ${selector}`;
    addLog(errorMsg, "error");
    throw new Error(errorMsg);
  }
}

// Scroll the page
function scrollPage(direction: string): void {
  const scrollAmount = window.innerHeight * 0.8;
  if (direction === "down") {
    window.scrollBy({ top: scrollAmount, behavior: "smooth" });
    addLog(`‰∏ã„Å´„Çπ„ÇØ„É≠„Éº„É´„Åó„Åæ„Åó„Åü (${scrollAmount}px)`, "success");
  } else if (direction === "up") {
    window.scrollBy({ top: -scrollAmount, behavior: "smooth" });
    addLog(`‰∏ä„Å´„Çπ„ÇØ„É≠„Éº„É´„Åó„Åæ„Åó„Åü (${scrollAmount}px)`, "success");
  }
}

// Get page information
function getPageInfo(type: string): string {
  switch (type) {
    case "title":
      return document.title;
    case "url":
      return window.location.href;
    case "text":
      return document.body.innerText.substring(0, 500);
    default:
      return "";
  }
}

// Listen for messages from popup
chrome.runtime.onMessage.addListener((request, _sender, sendResponse) => {
  if (request.type === "TOGGLE_KAIRU") {
    kairuEnabled = request.enabled;
    console.log("Kairu mode:", kairuEnabled ? "enabled" : "disabled");

    // Show or hide Kairu UI
    const container = document.getElementById(KAIRU_CONTAINER_ID);
    if (container) {
      container.style.display = kairuEnabled ? "block" : "none";
    }

    // Save enabled state to storage
    saveEnabledState(kairuEnabled);

    sendResponse({ success: true });
  }
  return true;
});

// Block all page interactions except Kairu UI
function blockPageInteractions(e: Event) {
  // Don't block if Kairu is disabled
  if (!kairuEnabled) {
    return;
  }

  const target = e.target as HTMLElement;

  // Allow interactions with Kairu UI
  if (target.closest(`#${KAIRU_CONTAINER_ID}`)) {
    return;
  }

  // Allow AI operations
  if (isAIOperating) {
    return;
  }

  // Block everything else
  e.preventDefault();
  e.stopPropagation();
}

// Initialize when page is fully loaded (including JS-generated content)
if (document.readyState === "complete") {
  // Page already loaded
  createKairuUI();
} else {
  // Wait for page to fully load
  window.addEventListener("load", () => {
    // Add small delay to allow JS to populate content
    setTimeout(createKairuUI, 500);
  });
}

// Block all interactions
const events = [
  "click",
  "mousedown",
  "mouseup",
  "keydown",
  "keypress",
  "keyup",
  "submit",
];
events.forEach((eventType) => {
  document.addEventListener(eventType, blockPageInteractions, true);
});
